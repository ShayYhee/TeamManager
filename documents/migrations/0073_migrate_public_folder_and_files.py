# Generated by Django 4.2.21 on 2025-09-05 19:33

from django.db import migrations, models
import os, uuid
import shutil
from django.conf import settings
from documents.models import upload_to_folder

def upload_to_folder(instance, filename):
    tenant_name = instance.tenant.name if instance.tenant else "default"
    username = instance.uploaded_by.username if instance.uploaded_by else "anonymous"
    folder_name = instance.folder.name if instance.folder else "unassigned"
    return os.path.join('uploads', tenant_name, username, folder_name, filename)

def migrate_public_folders_and_files(apps, schema_editor):
    PublicFolder = apps.get_model('documents', 'PublicFolder')
    PublicFile = apps.get_model('documents', 'PublicFile')
    Folder = apps.get_model('documents', 'Folder')
    File = apps.get_model('documents', 'File')

    public_folder_to_folder_map = {}
    default_folders = {}

    # Create default "unassigned" folders for PublicFile with folder=None
    for public_file in PublicFile.objects.filter(folder__isnull=True):
        key = (public_file.tenant_id, public_file.created_by_id)
        if key not in default_folders:
            default_folder = Folder(
                tenant=public_file.tenant,
                name="unassigned",
                created_by=public_file.created_by,
                is_public=True
            )
            try:
                default_folder.save()
            except Exception:
                default_folder = Folder.objects.get(
                    tenant=public_file.tenant,
                    name="unassigned",
                    created_by=public_file.created_by,
                    is_public=True
                )
            default_folders[key] = default_folder.id

    # Step 1: Migrate PublicFolder to Folder
    for public_folder in PublicFolder.objects.all():
        new_folder = Folder(
            tenant=public_folder.tenant,
            name=public_folder.name,
            parent=None,
            created_by=public_folder.created_by,
            created_at=public_folder.created_at,
            is_public=True
        )
        try:
            new_folder.save()
            public_folder_to_folder_map[public_folder.id] = new_folder.id
        except Exception:
            new_folder.name = f"{public_folder.name}_public"
            new_folder.save()
            public_folder_to_folder_map[public_folder.id] = new_folder.id

    # Step 2: Update parent relationships
    for public_folder in PublicFolder.objects.all():
        if public_folder.parent_id:
            new_folder = Folder.objects.get(id=public_folder_to_folder_map[public_folder.id])
            new_folder.parent_id = public_folder_to_folder_map.get(public_folder.parent_id)
            new_folder.save()

    # Step 3: Migrate PublicFile to File
    for public_file in PublicFile.objects.all():
        # Check for existing File with same tenant, uploaded_by, and original_name
        existing_file = File.objects.filter(
            tenant=public_file.tenant,
            uploaded_by=public_file.created_by,
            original_name=public_file.original_name
        ).first()

        if existing_file:
            print(f"Skipping PublicFile '{public_file.original_name}' (ID: {public_file.id}) as it already exists in File (ID: {existing_file.id})")
            continue  # Skip duplicate file

        new_folder_id = public_folder_to_folder_map.get(public_file.folder_id) if public_file.folder_id else default_folders.get((public_file.tenant_id, public_file.created_by_id))
        new_folder = Folder.objects.get(id=new_folder_id) if new_folder_id else None

        new_file = File(
            tenant=public_file.tenant,
            folder=new_folder,
            uploaded_by=public_file.created_by,
            original_name=public_file.original_name,
            uploaded_at=public_file.created_at,
            is_public=True,
            share_token=public_file.share_token,
            is_shared=public_file.is_shared,
            shared_by=public_file.shared_by
        )

        # Copy file to new path
        old_path = public_file.file.path
        new_path = upload_to_folder(new_file, public_file.original_name)
        new_full_path = os.path.join(settings.MEDIA_ROOT, new_path)
        os.makedirs(os.path.dirname(new_full_path), exist_ok=True)
        if os.path.exists(old_path):
            if os.path.exists(new_full_path):
                base, ext = os.path.splitext(new_path)
                new_path = f"{base}_public{ext}"
                new_full_path = os.path.join(settings.MEDIA_ROOT, new_path)
            shutil.copy2(old_path, new_full_path)
            new_file.file.name = new_path
        else:
            print(f"Warning: File {old_path} not found for PublicFile ID {public_file.id}")

        try:
            new_file.save()
        except Exception as e:
            # Regenerate share_token if there's a conflict
            new_file.share_token = uuid.uuid4()
            new_file.save()
            print(f"Generated new share_token for PublicFile '{public_file.original_name}' due to conflict: {new_file.share_token}")

def reverse_migration(apps, schema_editor):
    Folder = apps.get_model('documents', 'Folder')
    File = apps.get_model('documents', 'File')
    # Delete migrated folders and files
    Folder.objects.filter(is_public=True).delete()
    File.objects.filter(is_public=True).delete()

class Migration(migrations.Migration):

    dependencies = [
        ('documents', '0072_alter_file_folder'),
    ]

    operations = [
        migrations.RunPython(
            code=migrate_public_folders_and_files,
            reverse_code=reverse_migration,
        ),
    ]
